// SPDX-FileCopyrightText: 2022 SAP SE or an SAP affiliate company
// SPDX-License-Identifier: Apache-2.0

package makefile

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/sapcc/go-bits/must"

	"github.com/sapcc/go-makefile-maker/internal/core"
	"github.com/sapcc/go-makefile-maker/internal/golang"
	"github.com/sapcc/go-makefile-maker/internal/util"
)

// Render renders the Makefile.
func Render(cfg core.Configuration, sr golang.ScanResult) {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, core.AutogeneratedHeader)

	m := newMakefile(cfg, sr)
	for _, c := range m.categories {
		// Render category definitions.
		for _, def := range c.definitions {
			fmt.Fprintln(&buf, def)
		}
		if len(c.definitions) > 0 {
			// Put an empty line between definitions and rules.
			fmt.Fprintln(&buf)
		}

		// Render category rules.
		for _, r := range c.rules {
			r.render(&buf)
			// Put an empty line between rules.
			fmt.Fprintln(&buf)
		}

		// Add verbatim at the end of the general section.
		if c.name == "general" {
			if cfg.Verbatim != "" {
				fmt.Fprintln(&buf, FixRuleIndentation(cfg.Verbatim))
			}
		}
	}
	// Add targets generated from other targets at the end of the Makefile.
	m.vars().render(&buf)
	m.help().render(&buf)
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, ".PHONY: FORCE")

	must.Succeed(util.WriteFile("Makefile", buf.Bytes()))

	if sr.UsesPostgres {
		must.Succeed(os.MkdirAll("testing", os.ModePerm))

		// Cleanup obsolete helper script that was previously managed by this tool.
		err := os.Remove("testing/with-postgres-db.sh")
		if !os.IsNotExist(err) {
			must.Succeed(err)
		}
	}
}

// makefile holds the components of a Makefile.
type makefile struct {
	categories []category
}

func (m *makefile) vars() *rule {
	// collect all variable refs that look like $(THIS) or $(LIKE_THAT) from definitions and recipes
	varRefRx := regexp.MustCompile(`\$\([A-Za-z_][A-Za-z0-9_]*\)`)
	isVarRef := make(map[string]bool)
	searchIn := func(inputs []string) {
		for _, input := range inputs {
			for _, match := range varRefRx.FindAllString(input, -1) {
				isVarRef[match] = true
			}
		}
	}
	for _, c := range m.categories {
		searchIn(c.definitions)
		for _, r := range c.rules {
			searchIn(r.definitions)
			searchIn(r.recipe)
		}
	}

	// skip some variables that we only use internally to circumvent Makefile syntax limitations
	delete(isVarRef, "$(comma)")
	delete(isVarRef, "$(null)")
	delete(isVarRef, "$(space)")

	// compile a sorted list of variable names
	var varNames []string
	for varRef := range isVarRef {
		str := strings.TrimPrefix(varRef, "$(")
		str = strings.TrimSuffix(str, ")")
		varNames = append(varNames, str)
	}
	sort.Strings(varNames)

	// generate a target printing their values (the output is not colorized to allow usage like `eval "$(make vars)"`)
	result := rule{
		phony:  true,
		target: "vars",
	}
	for _, varName := range varNames {
		result.addRecipe(`@printf "%[1]s=$(%[1]s)\n"`, varName)
	}

	return &result
}

func (m *makefile) help() *rule {
	result := rule{
		phony:  true,
		target: "help",
		recipe: []string{
			`@printf "\n"`,
			fmt.Sprintf(`@printf "%s\n"`, brightStr("Usage:")),
			fmt.Sprintf(`@printf "  make %s\n"`, cyanStr("<target>")),
		},
	}

	// Find categories that don't have descriptive targets and find the target with the
	// longest name so that we can align the output.
	hasDescriptiveTarget := make(map[string]bool)
	var longestTargetCharCount int
	for _, c := range m.categories {
		for _, r := range c.rules {
			// duplicated with the code below
			if r.hideTarget || r.description == "" {
				continue
			}

			hasDescriptiveTarget[c.name] = true
			if chars := len(r.target); chars > longestTargetCharCount {
				longestTargetCharCount = chars
			}
		}
	}
	hasDescriptiveTarget["general"] = true // because `make vars/help` belong to general

	for _, c := range m.categories {
		cName := c.name
		if !hasDescriptiveTarget[cName] {
			continue
		}

		result.addRecipe(`@printf "\n"`)
		cNameTitleCase := strings.Title(cName) //nolint:staticcheck // ignore SA1019 (strings.Title is still fine for ASCII-only input)
		result.addRecipe(`@printf "%s\n"`, brightStr(cNameTitleCase))
		if cName == "general" {
			// Add help for targets generated from other targets.
			result.addRecipe(targetDescStr(longestTargetCharCount, "vars", "Display values of relevant Makefile variables."))
			result.addRecipe(targetDescStr(longestTargetCharCount, "help", "Display this help."))
		}

		for _, r := range c.rules {
			// duplicated with the logic for longestTargetCharCount
			if r.hideTarget || r.description == "" {
				continue
			}

			result.addRecipe(targetDescStr(longestTargetCharCount, r.target, r.description))
		}
	}

	return &result
}

// category is used for grouping related rules.
type category struct {
	name        string
	definitions []string
	rules       []rule
}

func (c *category) addDefinition(def string, args ...any) {
	if len(args) > 0 {
		def = fmt.Sprintf(def, args...)
	}
	c.definitions = append(c.definitions, def)
}

func (c *category) addRule(r ...rule) {
	c.rules = append(c.rules, r...)
}

// rule describes a Makefile rule.
type rule struct {
	// Description will be used in `make help`. If it is empty then this rule will not be
	// included in the help output.
	description string
	definitions []string
	phony       bool
	target      string
	hideTarget  bool // if true, the target will not be printed in the help output
	recipe      []string

	// See https://www.gnu.org/software/make/manual/make.html#Prerequisite-Types.
	prerequisites          []string
	orderOnlyPrerequisites []string
}

func (r *rule) addDefinition(def string, args ...any) {
	if len(args) > 0 {
		def = fmt.Sprintf(def, args...)
	}
	r.definitions = append(r.definitions, def)
}

func (r *rule) addRecipe(rec string, args ...any) {
	if len(args) > 0 {
		rec = fmt.Sprintf(rec, args...)
	}
	r.recipe = append(r.recipe, rec)
}

func (r *rule) render(w io.Writer) {
	// Render rule definitions.
	for _, def := range r.definitions {
		fmt.Fprintln(w, def)
	}
	if len(r.definitions) > 0 {
		// Put an empty line between rule and its definitions.
		fmt.Fprintln(w)
	}

	// Render rule hdr, i.e. target and prerequisites.
	hdr := r.target + ":"
	if r.phony {
		hdr += " FORCE"
	}
	if len(r.prerequisites) > 0 {
		hdr += " " + strings.Join(r.prerequisites, " ")
	}
	if len(r.orderOnlyPrerequisites) > 0 {
		hdr += " | " + strings.Join(r.orderOnlyPrerequisites, " ")
	}
	fmt.Fprintln(w, hdr)

	// Render rule recipe.
	for _, v := range r.recipe {
		fmt.Fprintf(w, "\t%s\n", v)
	}
}

///////////////////////////////////////////////////////////////////////////////
// Helper functions

func cyanStr(str string) string {
	return fmt.Sprintf(`\e[36m%s\e[0m`, str)
}

func brightStr(str string) string {
	return fmt.Sprintf(`\e[1m%s\e[0m`, str)
}

func targetDescStr(longestTargetCharCount int, target, desc string) string {
	diff := longestTargetCharCount - len(target)
	return fmt.Sprintf(`@printf "  %s%s%s\n"`,
		cyanStr(target), strings.Repeat(" ", diff+2), desc,
	)
}
