// Copyright 2022 SAP SE
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package makefile

import (
	_ "embed"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/sapcc/go-bits/must"

	"github.com/sapcc/go-makefile-maker/internal/core"
)

//go:embed with-postgres-db.sh
var withPostgresDBScript []byte

// Render renders the Makefile.
func Render(cfg *core.Configuration, sr core.ScanResult) {
	f := must.Return(os.Create("Makefile"))
	defer f.Close()

	fmt.Fprintln(f, core.AutogeneratedHeader)
	fmt.Fprintln(f)

	m := newMakefile(cfg, sr)
	for _, c := range m.categories {
		// Render category definitions.
		for _, def := range c.definitions {
			fmt.Fprintln(f, def)
		}
		if len(c.definitions) > 0 {
			// Put an empty line between definitions and rules.
			fmt.Fprintln(f)
		}

		// Render category rules.
		for _, r := range c.rules {
			r.render(f)
			// Put an empty line between rules.
			fmt.Fprintln(f)
		}

		// Add verbatim at the end of the general section.
		if c.name == "general" {
			if cfg.Verbatim != "" {
				fmt.Fprintln(f, FixRuleIndentation(cfg.Verbatim))
			}
		}
	}
	// Add help and phony target at the end of the Makefile.
	m.help().render(f)
	fmt.Fprintln(f)
	fmt.Fprintln(f, ".PHONY: FORCE")

	if sr.UsesPostgres {
		must.Succeed(os.Mkdir("testing", os.ModePerm))
		must.Succeed(os.WriteFile("testing/with-postgres-db.sh", withPostgresDBScript, 0666))
	}
}

// makefile holds the components of a Makefile.
type makefile struct {
	categories []category
}

func (m *makefile) help() *rule {
	result := rule{
		phony:  true,
		target: "help",
		recipe: []string{
			`@printf "\n"`,
			fmt.Sprintf(`@printf "%s\n"`, brightStr("Usage:")),
			fmt.Sprintf(`@printf "  make %s\n"`, cyanStr("<target>")),
		},
	}

	// Find categories that don't have descriptive targets and find the target with the
	// longest name so that we can align the output.
	hasDescriptiveTarget := make(map[string]bool)
	var longestTargetCharCount int
	for _, c := range m.categories {
		for _, r := range c.rules {
			if r.description != "" {
				hasDescriptiveTarget[c.name] = true
				if chars := len(r.target); chars > longestTargetCharCount {
					longestTargetCharCount = chars
				}
			}
		}
	}
	hasDescriptiveTarget["general"] = true // because `make help` belongs to general

	for _, c := range m.categories {
		cName := c.name
		if !hasDescriptiveTarget[cName] {
			continue
		}

		result.addRecipe(`@printf "\n"`)
		cNameTitleCase := strings.Title(cName) //nolint:staticcheck //ignore SA1019 (strings.Title is still fine for ASCII-only input)
		result.addRecipe(`@printf "%s\n"`, brightStr(cNameTitleCase))
		if cName == "general" {
			// Add help description to general.
			result.addRecipe(targetDescStr(longestTargetCharCount, "help", "Display this help."))
		}

		for _, r := range c.rules {
			if r.description != "" {
				result.addRecipe(targetDescStr(longestTargetCharCount, r.target, r.description))
			}
		}
	}

	return &result
}

// category is used for grouping related rules.
type category struct {
	name        string
	definitions []string
	rules       []rule
}

func (c *category) addDefinition(def string, args ...interface{}) {
	if len(args) > 0 {
		def = fmt.Sprintf(def, args...)
	}
	c.definitions = append(c.definitions, def)
}

func (c *category) addRule(r ...rule) {
	c.rules = append(c.rules, r...)
}

// rule describes a Makefile rule.
type rule struct {
	// Description will be used in `make help`. If it is empty then this rule will not be
	// included in the help output.
	description string
	definitions []string
	phony       bool
	target      string
	recipe      []string

	// See https://www.gnu.org/software/make/manual/make.html#Prerequisite-Types.
	prerequisites          []string
	orderOnlyPrerequisites []string
}

func (r *rule) addDefinition(def string, args ...interface{}) {
	if len(args) > 0 {
		def = fmt.Sprintf(def, args...)
	}
	r.definitions = append(r.definitions, def)
}

func (r *rule) addRecipe(rec string, args ...interface{}) {
	if len(args) > 0 {
		rec = fmt.Sprintf(rec, args...)
	}
	r.recipe = append(r.recipe, rec)
}

func (r *rule) render(w io.Writer) {
	// Render rule definitions.
	for _, def := range r.definitions {
		fmt.Fprintln(w, def)
	}
	if len(r.definitions) > 0 {
		// Put an empty line between rule and its definitions.
		fmt.Fprintln(w)
	}

	// Render rule hdr, i.e. target and prerequisites.
	hdr := r.target + ":"
	if r.phony {
		hdr += " FORCE"
	}
	if len(r.prerequisites) > 0 {
		hdr += fmt.Sprintf(" %s", strings.Join(r.prerequisites, " "))
	}
	if len(r.orderOnlyPrerequisites) > 0 {
		hdr += fmt.Sprintf(" | %s", strings.Join(r.orderOnlyPrerequisites, " "))
	}
	fmt.Fprintln(w, hdr)

	// Render rule recipe.
	for _, v := range r.recipe {
		fmt.Fprintf(w, "\t%s\n", v)
	}
}

///////////////////////////////////////////////////////////////////////////////
// Helper functions

func cyanStr(str string) string {
	return fmt.Sprintf(`\e[36m%s\e[0m`, str)
}

func brightStr(str string) string {
	return fmt.Sprintf(`\e[1m%s\e[0m`, str)
}

func targetDescStr(longestTargetCharCount int, target, desc string) string {
	diff := longestTargetCharCount - len(target)
	return fmt.Sprintf(`@printf "  %s%s%s\n"`,
		cyanStr(target), strings.Repeat(" ", diff+2), desc,
	)
}
