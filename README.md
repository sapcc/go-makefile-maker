# go-makefile-maker

Makes a Makefile for your Go application that follows established Unix conventions for installing and packaging, and includes targets for vendoring, running tests and checking code quality.

## Installation

The easiest way is `go get github.com/sapcc/go-makefile-maker`.

We also support the usual Makefile invocations: `make`, `make check` and `make install`. The latter understands the conventional environment variables for choosing install locations, `DESTDIR` and `PREFIX`.
You usually want something like `make && sudo make install PREFIX=/usr/local`.

## Usage

Put a `Makefile.maker.yaml` in your Git repository's root directory, then run `go-makefile-maker` to render the Makefile from it.
Commit both the `Makefile.maker.yaml` and the Makefile, so that your users don't need to have `go-makefile-maker` installed.
The `Makefile.maker.yaml` is a YAML file with the following sections.

### `binaries`

```yaml
binaries:
  - name:        example
    fromPackage: ./cmd/example
    installTo:   bin/
  - name:        test-helper
    fromPackage: ./cmd/test-helper
```

For each binary specified here, a target will be generated that builds it with `go build` and puts it in `build/$NAME`.
The `fromPackage` is a Go module path relative to the directory containing the Makefile.

If `installTo` is set for at least one binary, the `install` target is added to the Makefile, and all binaries with `installTo` are installed by it.
In this case, `example` would be installed as `/usr/bin/example` by default, and `test-helper` would not be installed.

### `coverageTest`

```yaml
coverageTest:
  only: '/internal'
  except: '/test/util|/test/mock'
```

When `make check` runs `go test`, it produces a test coverage report.
By default, all packages inside the repository are subject to coverage testing, but this section can be used to restrict this.
The values in `only` and `except` are regexes for `grep -E`.
Since only entire packages (not single source files) can be selected for coverage testing, the regexes have to match package names, not on file names.

### `variables`

```yaml
variables:
  GO_BUILDFLAGS: '-mod vendor'
  GO_LDFLAGS: ''
  GO_TESTENV: ''
```

Allows to override the default values of Makefile variables used by the autogenerated recipes.
This mechanism cannot be used to define new variables to use in your own rules; use `verbatim` for that.
By default, all accepted variables are empty.
The only exception is that `GO_BUILDFLAGS` defaults to `-mod vendor` when vendoring is enabled (see below).

A typical usage of this is to give compile-time values to the Go compiler with the `-X` linker flag:

```yaml
variables:
  GO_LDFLAGS: '-X github.com/foo/bar.Version = $(shell git describe --abbrev=7)'
```

`GO_TESTENV` can contain environment variables to pass to `go test`:

```yaml
variables:
  GO_TESTENV: 'POSTGRES_HOST=localhost POSTGRES_DATABASE=unittestdb'
```

### `vendoring`

```yaml
vendoring:
  enabled: false
```

Set `vendoring.enabled` to `true` if you vendor all dependencies in your repository. With vendoring enabled:

1. The default for `GO_BUILDFLAGS` is set to `-mod vendor`, so that build targets default to using vendored dependencies.
   This means that building binaries does not require a network connection.
2. The `make tidy-deps` target is replaced by a `make vendor` target that runs `go mod tidy && go mod verify` just like `make tidy-deps`, but also runs `go
   mod vendor`.
   This target can be used to get the vendor directory up-to-date before commits.

### `verbatim`

```yaml
verbatim: |
  run-example: build/example
    ./build/example example-config.txt
```

This field can be used to add your own definitions and rules to the Makefile.
The text in this field is copied into the Makefile mostly verbatim, with one exception:
Since YAML does not like tabs for indentation, we allow rule recipes to be indented with spaces.
This indentation will be replaced with tabs before writing it into the actual Makefile.
